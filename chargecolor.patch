diff --git |
--- a/config.def.h	2025-07-11 12:40:04.649477979 +0500
+++ b/config.def.h	2025-09-17 13:30:07.039306825 +0500
@@ -1,100 +1,161 @@
static const int showbar            = 1;        /* 0 means no bar */
static const int topbar             = 1;        /* 0 means bottom bar */
static const char *fonts[]          = { "monospace:size=10" };
-static const char dmenufont[]       = "monospace:size=10";
-static const char col_gray1[]       = "#222222";
-static const char col_gray2[]       = "#444444";
-static const char col_gray3[]       = "#bbbbbb";
-static const char col_gray4[]       = "#eeeeee";
-static const char col_cyan[]        = "#005577";
-static const char *colors[][3]      = {
-	/*               fg         bg         border   */
-	[SchemeNorm] = { col_gray3, col_gray1, col_gray2 },
-	[SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
+char *colors[][3] = { // default colors as backup
+ 	/*               text       bg         border   */
+	[SchemeNorm] = { "#ffffff", "#222222", "#444444" },
+	[SchemeSel]  = { "#ffffff", "#005577", "#005577" },
+ }; // the bg color is mainly used for the status bar,
+	 // it doesnt visibly effect any client windows
 
+static const char **current_theme = NULL; // variable to apply final changes | DO NOT CHANGE
+static const char *main_theme[]	= { "#FFFFFF", "#0E1C4A", "#3E54BD" }; // theme while charging
+static const char *altr_theme[]	= { "#FFFFFF", "#340B07", "#73493D" }; // theme while discharging
 
--- a/dwm.c	2025-07-11 16:23:56.314010000 +0500
+++ b/dwm.c	2025-09-20 10:42:19.086750803 +0500
@@ -30,6 +30,7 @@
 #include <unistd.h>
 #include <sys/types.h>
 #include <sys/wait.h>
+#include <pthread.h>
 #include <X11/cursorfont.h>
 #include <X11/keysym.h>
 #include <X11/Xatom.h>
@@ -176,6 +177,7 @@
 static void grabbuttons(Client *c, int focused);
 static void grabkeys(void);
 static void incnmaster(const Arg *arg);
+static int ischarging(void);
+#include <dirent.h>
+#include <sys/stat.h>
 static void keypress(XEvent *e);
 static void killclient(const Arg *arg);
 static void manage(Window w, XWindowAttributes *wa);
@@ -216,6 +218,7 @@
 static void unfocus(Client *c, int setfocus);
 static void unmanage(Client *c, int destroyed);
 static void unmapnotify(XEvent *e);
+static void updatecolors(void);
 static void updatebarpos(Monitor *m);
 static void updatebars(void);
 static void updateclientlist(void);
@@ -241,6 +244,7 @@
 static int sw, sh;           /* X display screen geometry width, height */
 static int bh;               /* bar height */
 static int lrpad;            /* sum of left and right padding for text */
+static int colorpipe[2];     /* pipe for notifying main thread about color changes */
 static int (*xerrorxlib)(Display *, XErrorEvent *);
 static unsigned int numlockmask = 0;
 static void (*handler[LASTEvent]) (XEvent *) = {
@@ -494,6 +498,8 @@
 	XSync(dpy, False);
 	XSetInputFocus(dpy, PointerRoot, RevertToPointerRoot, CurrentTime);
 	XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
+	close(colorpipe[0]);
+	close(colorpipe[1]);
 }
 
 void
@@ -984,6 +990,44 @@
 	arrange(selmon);
 }
 
+int
+ischarging(void) {
+    const char *base = "/sys/class/power_supply/";
+    DIR *dir = opendir(base);
+    if (!dir) return 0;
+
+    struct dirent *entry;
+    char path[PATH_MAX];
+    FILE *f;
+    int status = 0;
+
+    while ((entry = readdir(dir))) {
+        if (entry->d_type != DT_DIR && entry->d_type != DT_LNK)
+            continue;
+
+        snprintf(path, sizeof(path), "%s%s/type", base, entry->d_name);
+        f = fopen(path, "r");
+        if (!f) continue;
+
+        char type[32];
+        if (fgets(type, sizeof(type), f)) {
+            if (strncmp(type, "Mains", 5) == 0) {
+                fclose(f);
+                snprintf(path, sizeof(path), "%s%s/online", base, entry->d_name);
+                f = fopen(path, "r");
+                if (!f) break;
+                fscanf(f, "%d", &status);
+                fclose(f);
+                break;
+            }
+        }
+        fclose(f);
+    }
+
+    closedir(dir);
+    return status;
+}
+
 #ifdef XINERAMA
 static int
 isuniquegeom(XineramaScreenInfo *unique, size_t n, XineramaScreenInfo *info)
@@ -1383,11 +1427,36 @@
 run(void)
 {
 	XEvent ev;
-	/* main event loop */
-	XSync(dpy, False);
-	while (running && !XNextEvent(dpy, &ev))
-		if (handler[ev.type])
-			handler[ev.type](&ev); /* call handler */
+	int x11_fd = ConnectionNumber(dpy);
+	int maxfd = (colorpipe[0] > x11_fd) ? colorpipe[0] : x11_fd;
+
+	fd_set rfds;
+
+	while (running) {
+		FD_ZERO(&rfds);
+		FD_SET(x11_fd, &rfds);
+		FD_SET(colorpipe[0], &rfds);
+
+		if (select(maxfd + 1, &rfds, NULL, NULL, NULL) < 0) {
+			if (errno == EINTR)
+				continue;
+			die("select failed");
+		}
+
+		if (FD_ISSET(colorpipe[0], &rfds)) {
+			char buf[1];
+			read(colorpipe[0], buf, 1);  /* clear pipe */
+			updatecolors();              /* safe update in main thread */
+		}
+
+		if (FD_ISSET(x11_fd, &rfds)) {
+			while (XPending(dpy)) {
+				XNextEvent(dpy, &ev);
+				if (handler[ev.type])
+					handler[ev.type](&ev);
+			}
+		}
+	}
 }
 
 void
@@ -1583,10 +1652,13 @@
 	cursor[CurNormal] = drw_cur_create(drw, XC_left_ptr);
 	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
 	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
+	if (pipe(colorpipe) == -1) {
+		die("Failed to create pipe");
+	}
 	/* init appearance */
 	scheme = ecalloc(LENGTH(colors), sizeof(Clr *));
 	for (i = 0; i < LENGTH(colors); i++)
-		scheme[i] = drw_scm_create(drw, colors[i], 3);
+		scheme[i] = drw_scm_create(drw, (const char **)colors[i], 3);
 	/* init bars */
 	updatebars();
 	updatestatus();
@@ -1649,8 +1721,8 @@
 {
 	struct sigaction sa;
 
-	if (arg->v == dmenucmd)
-		dmenumon[0] = '0' + selmon->num;
+	if (arg->v == roficmd)
+		rofimon[0] = '0' + selmon->num;
 	if (fork() == 0) {
 		if (dpy)
 			close(ConnectionNumber(dpy));
@@ -1712,6 +1784,21 @@
 		}
 }
 
+void *
+themechecker(void *arg) {
+	int last_status = -1;
+	for (;;) {
+		int charging = ischarging();
+		if (charging != last_status) {
+			current_theme = charging ? main_theme : altr_theme;
+			updatecolors();
+			last_status = charging;
+		}
+		usleep(1000000);
+	}
+	return NULL;
+}
+
 void
 togglebar(const Arg *arg)
 {
@@ -1816,6 +1903,34 @@
 }
 
 void
+updatecolors(void) {
+	colors[SchemeNorm][0] = (char *)current_theme[0];
+	colors[SchemeNorm][1] = (char *)current_theme[1];
+	colors[SchemeNorm][2] = (char *)current_theme[1];
+
+	colors[SchemeSel][0] = (char *)current_theme[0];
+	colors[SchemeSel][1] = (char *)current_theme[2];
+	colors[SchemeSel][2] = (char *)current_theme[2];
+
+	for (int i = 0; i < LENGTH(colors); i++) {
+		if (scheme[i])
+			free(scheme[i]);
+		scheme[i] = drw_scm_create(drw, (const char **)colors[i], 3);
+	}
+
+	for (Monitor *m = mons; m; m = m->next) {
+		drawbar(m);
+		arrange(m);
+
+		/* Update borders of all clients on this monitor */
+		for (Client *c = m->clients; c; c = c->next) {
+			XSetWindowBorder(dpy, c->win,
+					scheme[c == m->sel ? SchemeSel : SchemeNorm][2].pixel);
+		}
+	}
+}
+
+void
 updatebars(void)
 {
 	Monitor *m;
@@ -2153,12 +2268,17 @@
 		die("dwm: cannot open display");
 	checkotherwm();
 	setup();
+
+	pthread_t theme_thread;
+	pthread_create(&theme_thread, NULL, themechecker, NULL);
+
 #ifdef __OpenBSD__
 	if (pledge("stdio rpath proc exec", NULL) == -1)
 		die("pledge");
 #endif /* __OpenBSD__ */
 	scan();
 	run();
+	pthread_join(theme_thread, NULL);
 	cleanup();
 	XCloseDisplay(dpy);
 	return EXIT_SUCCESS;
