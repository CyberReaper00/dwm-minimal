--- dwm.c.orig	2025-07-11 16:23:56.314010000 +0500
+++ dwm.c	2025-09-17 13:30:27.272126211 +0500
@@ -30,6 +30,7 @@
 #include <unistd.h>
 #include <sys/types.h>
 #include <sys/wait.h>
+#include <pthread.h>
 #include <X11/cursorfont.h>
 #include <X11/keysym.h>
 #include <X11/Xatom.h>
@@ -176,6 +177,7 @@
 static void grabbuttons(Client *c, int focused);
 static void grabkeys(void);
 static void incnmaster(const Arg *arg);
+static int ischarging(void);
 static void keypress(XEvent *e);
 static void killclient(const Arg *arg);
 static void manage(Window w, XWindowAttributes *wa);
@@ -216,6 +218,7 @@
 static void unfocus(Client *c, int setfocus);
 static void unmanage(Client *c, int destroyed);
 static void unmapnotify(XEvent *e);
+static void updatecolors(void);
 static void updatebarpos(Monitor *m);
 static void updatebars(void);
 static void updateclientlist(void);
@@ -241,6 +244,7 @@
 static int sw, sh;           /* X display screen geometry width, height */
 static int bh;               /* bar height */
 static int lrpad;            /* sum of left and right padding for text */
+static int colorpipe[2];     /* pipe for notifying main thread about color changes */
 static int (*xerrorxlib)(Display *, XErrorEvent *);
 static unsigned int numlockmask = 0;
 static void (*handler[LASTEvent]) (XEvent *) = {
@@ -494,6 +498,8 @@
 	XSync(dpy, False);
 	XSetInputFocus(dpy, PointerRoot, RevertToPointerRoot, CurrentTime);
 	XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
+	close(colorpipe[0]);
+	close(colorpipe[1]);
 }
 
 void
@@ -984,6 +990,16 @@
 	arrange(selmon);
 }
 
+int
+ischarging(void) {
+	FILE *f = fopen("/sys/class/power_supply/AC/online", "r");
+	if (!f) return 0;
+	int status = 0;
+	fscanf(f, "%d", &status);
+	fclose(f);
+	return status;
+}
+
 #ifdef XINERAMA
 static int
 isuniquegeom(XineramaScreenInfo *unique, size_t n, XineramaScreenInfo *info)
@@ -1383,11 +1399,36 @@
 run(void)
 {
 	XEvent ev;
-	/* main event loop */
-	XSync(dpy, False);
-	while (running && !XNextEvent(dpy, &ev))
-		if (handler[ev.type])
-			handler[ev.type](&ev); /* call handler */
+	int x11_fd = ConnectionNumber(dpy);
+	int maxfd = (colorpipe[0] > x11_fd) ? colorpipe[0] : x11_fd;
+
+	fd_set rfds;
+
+	while (running) {
+		FD_ZERO(&rfds);
+		FD_SET(x11_fd, &rfds);
+		FD_SET(colorpipe[0], &rfds);
+
+		if (select(maxfd + 1, &rfds, NULL, NULL, NULL) < 0) {
+			if (errno == EINTR)
+				continue;
+			die("select failed");
+		}
+
+		if (FD_ISSET(colorpipe[0], &rfds)) {
+			char buf[1];
+			read(colorpipe[0], buf, 1);  /* clear pipe */
+			updatecolors();              /* safe update in main thread */
+		}
+
+		if (FD_ISSET(x11_fd, &rfds)) {
+			while (XPending(dpy)) {
+				XNextEvent(dpy, &ev);
+				if (handler[ev.type])
+					handler[ev.type](&ev);
+			}
+		}
+	}
 }
 
 void
@@ -1583,10 +1624,13 @@
 	cursor[CurNormal] = drw_cur_create(drw, XC_left_ptr);
 	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
 	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
+	if (pipe(colorpipe) == -1) {
+		die("Failed to create pipe");
+	}
 	/* init appearance */
 	scheme = ecalloc(LENGTH(colors), sizeof(Clr *));
 	for (i = 0; i < LENGTH(colors); i++)
-		scheme[i] = drw_scm_create(drw, colors[i], 3);
+		scheme[i] = drw_scm_create(drw, (const char **)colors[i], 3);
 	/* init bars */
 	updatebars();
 	updatestatus();
@@ -1649,8 +1693,8 @@
 {
 	struct sigaction sa;
 
-	if (arg->v == dmenucmd)
-		dmenumon[0] = '0' + selmon->num;
+	if (arg->v == roficmd)
+		rofimon[0] = '0' + selmon->num;
 	if (fork() == 0) {
 		if (dpy)
 			close(ConnectionNumber(dpy));
@@ -1712,6 +1756,21 @@
 		}
 }
 
+void *
+themechecker(void *arg) {
+	int last_status = -1;
+	for (;;) {
+		int charging = ischarging();
+		if (charging != last_status) {
+			current_theme = charging ? main_theme : altr_theme;
+			updatecolors();
+			last_status = charging;
+		}
+		usleep(1000000);
+	}
+	return NULL;
+}
+
 void
 togglebar(const Arg *arg)
 {
@@ -1816,6 +1875,34 @@
 }
 
 void
+updatecolors(void) {
+	colors[SchemeNorm][0] = (char *)current_theme[0];
+	colors[SchemeNorm][1] = (char *)current_theme[1];
+	colors[SchemeNorm][2] = (char *)current_theme[1];
+
+	colors[SchemeSel][0] = (char *)current_theme[0];
+	colors[SchemeSel][1] = (char *)current_theme[2];
+	colors[SchemeSel][2] = (char *)current_theme[2];
+
+	for (int i = 0; i < LENGTH(colors); i++) {
+		if (scheme[i])
+			free(scheme[i]);
+		scheme[i] = drw_scm_create(drw, (const char **)colors[i], 3);
+	}
+
+	for (Monitor *m = mons; m; m = m->next) {
+		drawbar(m);
+		arrange(m);
+
+		/* Update borders of all clients on this monitor */
+		for (Client *c = m->clients; c; c = c->next) {
+			XSetWindowBorder(dpy, c->win,
+					scheme[c == m->sel ? SchemeSel : SchemeNorm][2].pixel);
+		}
+	}
+}
+
+void
 updatebars(void)
 {
 	Monitor *m;
@@ -2153,12 +2240,17 @@
 		die("dwm: cannot open display");
 	checkotherwm();
 	setup();
+
+	pthread_t theme_thread;
+	pthread_create(&theme_thread, NULL, themechecker, NULL);
+
 #ifdef __OpenBSD__
 	if (pledge("stdio rpath proc exec", NULL) == -1)
 		die("pledge");
 #endif /* __OpenBSD__ */
 	scan();
 	run();
+	pthread_join(theme_thread, NULL);
 	cleanup();
 	XCloseDisplay(dpy);
 	return EXIT_SUCCESS;
